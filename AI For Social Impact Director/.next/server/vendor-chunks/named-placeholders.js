"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/named-placeholders";
exports.ids = ["vendor-chunks/named-placeholders"];
exports.modules = {

/***/ "(rsc)/./node_modules/named-placeholders/index.js":
/*!**************************************************!*\
  !*** ./node_modules/named-placeholders/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\n\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,\n  DQUOTE = 34,\n  SQUOTE = 39,\n  BSLASH = 92;\n\nfunction parse(query) {\n  let ppos = RE_PARAM.exec(query);\n  let curpos = 0;\n  let start = 0;\n  let end;\n  const parts = [];\n  let inQuote = false;\n  let escape = false;\n  let qchr;\n  const tokens = [];\n  let qcnt = 0;\n  let lastTokenEndPos = 0;\n  let i;\n\n  if (ppos) {\n    do {\n      for (i = curpos, end = ppos.index; i < end; ++i) {\n        const chr = query.charCodeAt(i);\n        if (chr === BSLASH) escape = !escape;\n        else {\n          if (escape) {\n            escape = false;\n            continue;\n          }\n          if (inQuote && chr === qchr) {\n            if (query.charCodeAt(i + 1) === qchr) {\n              // quote escaped via \"\" or ''\n              ++i;\n              continue;\n            }\n            inQuote = false;\n          } else if (!inQuote && (chr === DQUOTE || chr === SQUOTE)) {\n            inQuote = true;\n            qchr = chr;\n          }\n        }\n      }\n      if (!inQuote) {\n        parts.push(query.substring(start, end));\n        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n        start = end + ppos[0].length;\n        lastTokenEndPos = start;\n      }\n      curpos = end + ppos[0].length;\n    } while ((ppos = RE_PARAM.exec(query)));\n\n    if (tokens.length) {\n      if (curpos < query.length) {\n        parts.push(query.substring(lastTokenEndPos));\n      }\n      return [parts, tokens];\n    }\n  }\n  return [query];\n}\n\nfunction createCompiler(config) {\n  if (!config) config = {};\n  if (!config.placeholder) {\n    config.placeholder = '?';\n  }\n  let ncache = 100;\n  let cache;\n  if (typeof config.cache === 'number') {\n    ncache = config.cache;\n  }\n  if (typeof config.cache === 'object') {\n    cache = config.cache;\n  }\n  if (config.cache !== false && !cache) {\n    cache = (__webpack_require__(/*! lru.min */ \"(rsc)/./node_modules/lru.min/lib/index.js\").createLRU)({ max: ncache });\n  }\n\n  function toArrayParams(tree, params) {\n    const arr = [];\n    if (tree.length === 1) {\n      return [tree[0], []];\n    }\n\n    if (typeof params === 'undefined')\n      throw new Error(\n        'Named query contains placeholders, but parameters object is undefined'\n      );\n\n    const tokens = tree[1];\n    for (let i = 0; i < tokens.length; ++i) {\n      arr.push(params[tokens[i]]);\n    }\n    return [tree[0], arr];\n  }\n\n  function noTailingSemicolon(s) {\n    if (s.slice(-1) === ':') {\n      return s.slice(0, -1);\n    }\n    return s;\n  }\n\n  function join(tree) {\n    if (tree.length === 1) {\n      return tree;\n    }\n\n    let unnamed = noTailingSemicolon(tree[0][0]);\n    for (let i = 1; i < tree[0].length; ++i) {\n      if (tree[0][i - 1].slice(-1) === ':') {\n        unnamed += config.placeholder;\n      }\n      unnamed += config.placeholder;\n      unnamed += noTailingSemicolon(tree[0][i]);\n    }\n\n    const last = tree[0][tree[0].length - 1];\n    if (tree[0].length === tree[1].length) {\n      if (last.slice(-1) === ':') {\n        unnamed += config.placeholder;\n      }\n      unnamed += config.placeholder;\n    }\n    return [unnamed, tree[1]];\n  }\n\n  function compile(query, paramsObj) {\n    let tree;\n    if (cache && (tree = cache.get(query))) {\n      return toArrayParams(tree, paramsObj);\n    }\n    tree = join(parse(query));\n    if (cache) {\n      cache.set(query, tree);\n    }\n    return toArrayParams(tree, paramsObj);\n  }\n\n  compile.parse = parse;\n  return compile;\n}\n\n// named :one :two to postgres-style numbered $1 $2 $3\nfunction toNumbered(q, params) {\n  const tree = parse(q);\n  const paramsArr = [];\n  if (tree.length === 1) {\n    return [tree[0], paramsArr];\n  }\n\n  const pIndexes = {};\n  let pLastIndex = 0;\n  let qs = '';\n  let varIndex;\n  const varNames = [];\n  for (let i = 0; i < tree[0].length; ++i) {\n    varIndex = pIndexes[tree[1][i]];\n    if (!varIndex) {\n      varIndex = ++pLastIndex;\n      pIndexes[tree[1][i]] = varIndex;\n    }\n    if (tree[1][i]) {\n      varNames[varIndex - 1] = tree[1][i];\n      qs += `${tree[0][i]}$${varIndex}`;\n    } else {\n      qs += tree[0][i];\n    }\n  }\n  return [qs, varNames.map((n) => params[n])];\n}\n\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmFtZWQtcGxhY2Vob2xkZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkZBQTRCLEdBQUcsYUFBYTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVcsR0FBRyxTQUFTO0FBQ3RDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWkteW91dGgtZGlyZWN0b3Itc2Rncy8uL25vZGVfbW9kdWxlcy9uYW1lZC1wbGFjZWhvbGRlcnMvaW5kZXguanM/N2E3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGJhc2VkIG9uIGNvZGUgZnJvbSBCcmlhbiBXaGl0ZSBAbXNjZGV4IG1hcmlhc3FsIGxpYnJhcnkgLSBodHRwczovL2dpdGh1Yi5jb20vbXNjZGV4L25vZGUtbWFyaWFzcWwvYmxvYi9tYXN0ZXIvbGliL0NsaWVudC5qcyNMMjcyLUwzMzJcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tc2NkZXgvbm9kZS1tYXJpYXNxbC9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmNvbnN0IFJFX1BBUkFNID0gLyg/OlxcPyl8KD86OihcXGQrfCg/OlthLXpBLVpdW2EtekEtWjAtOV9dKikpKS9nLFxuICBEUVVPVEUgPSAzNCxcbiAgU1FVT1RFID0gMzksXG4gIEJTTEFTSCA9IDkyO1xuXG5mdW5jdGlvbiBwYXJzZShxdWVyeSkge1xuICBsZXQgcHBvcyA9IFJFX1BBUkFNLmV4ZWMocXVlcnkpO1xuICBsZXQgY3VycG9zID0gMDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZDtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgbGV0IGluUXVvdGUgPSBmYWxzZTtcbiAgbGV0IGVzY2FwZSA9IGZhbHNlO1xuICBsZXQgcWNocjtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGxldCBxY250ID0gMDtcbiAgbGV0IGxhc3RUb2tlbkVuZFBvcyA9IDA7XG4gIGxldCBpO1xuXG4gIGlmIChwcG9zKSB7XG4gICAgZG8ge1xuICAgICAgZm9yIChpID0gY3VycG9zLCBlbmQgPSBwcG9zLmluZGV4OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hyID0gcXVlcnkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNociA9PT0gQlNMQVNIKSBlc2NhcGUgPSAhZXNjYXBlO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5RdW90ZSAmJiBjaHIgPT09IHFjaHIpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gcWNocikge1xuICAgICAgICAgICAgICAvLyBxdW90ZSBlc2NhcGVkIHZpYSBcIlwiIG9yICcnXG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICghaW5RdW90ZSAmJiAoY2hyID09PSBEUVVPVEUgfHwgY2hyID09PSBTUVVPVEUpKSB7XG4gICAgICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHFjaHIgPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWluUXVvdGUpIHtcbiAgICAgICAgcGFydHMucHVzaChxdWVyeS5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgICAgICB0b2tlbnMucHVzaChwcG9zWzBdLmxlbmd0aCA9PT0gMSA/IHFjbnQrKyA6IHBwb3NbMV0pO1xuICAgICAgICBzdGFydCA9IGVuZCArIHBwb3NbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0VG9rZW5FbmRQb3MgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIGN1cnBvcyA9IGVuZCArIHBwb3NbMF0ubGVuZ3RoO1xuICAgIH0gd2hpbGUgKChwcG9zID0gUkVfUEFSQU0uZXhlYyhxdWVyeSkpKTtcblxuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoY3VycG9zIDwgcXVlcnkubGVuZ3RoKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocXVlcnkuc3Vic3RyaW5nKGxhc3RUb2tlbkVuZFBvcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtwYXJ0cywgdG9rZW5zXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtxdWVyeV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZykgY29uZmlnID0ge307XG4gIGlmICghY29uZmlnLnBsYWNlaG9sZGVyKSB7XG4gICAgY29uZmlnLnBsYWNlaG9sZGVyID0gJz8nO1xuICB9XG4gIGxldCBuY2FjaGUgPSAxMDA7XG4gIGxldCBjYWNoZTtcbiAgaWYgKHR5cGVvZiBjb25maWcuY2FjaGUgPT09ICdudW1iZXInKSB7XG4gICAgbmNhY2hlID0gY29uZmlnLmNhY2hlO1xuICB9XG4gIGlmICh0eXBlb2YgY29uZmlnLmNhY2hlID09PSAnb2JqZWN0Jykge1xuICAgIGNhY2hlID0gY29uZmlnLmNhY2hlO1xuICB9XG4gIGlmIChjb25maWcuY2FjaGUgIT09IGZhbHNlICYmICFjYWNoZSkge1xuICAgIGNhY2hlID0gcmVxdWlyZSgnbHJ1Lm1pbicpLmNyZWF0ZUxSVSh7IG1heDogbmNhY2hlIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9BcnJheVBhcmFtcyh0cmVlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBpZiAodHJlZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBbdHJlZVswXSwgW11dO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05hbWVkIHF1ZXJ5IGNvbnRhaW5zIHBsYWNlaG9sZGVycywgYnV0IHBhcmFtZXRlcnMgb2JqZWN0IGlzIHVuZGVmaW5lZCdcbiAgICAgICk7XG5cbiAgICBjb25zdCB0b2tlbnMgPSB0cmVlWzFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcnIucHVzaChwYXJhbXNbdG9rZW5zW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBbdHJlZVswXSwgYXJyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vVGFpbGluZ1NlbWljb2xvbihzKSB7XG4gICAgaWYgKHMuc2xpY2UoLTEpID09PSAnOicpIHtcbiAgICAgIHJldHVybiBzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBmdW5jdGlvbiBqb2luKHRyZWUpIHtcbiAgICBpZiAodHJlZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cblxuICAgIGxldCB1bm5hbWVkID0gbm9UYWlsaW5nU2VtaWNvbG9uKHRyZWVbMF1bMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdHJlZVswXS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRyZWVbMF1baSAtIDFdLnNsaWNlKC0xKSA9PT0gJzonKSB7XG4gICAgICAgIHVubmFtZWQgKz0gY29uZmlnLnBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgdW5uYW1lZCArPSBjb25maWcucGxhY2Vob2xkZXI7XG4gICAgICB1bm5hbWVkICs9IG5vVGFpbGluZ1NlbWljb2xvbih0cmVlWzBdW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0ID0gdHJlZVswXVt0cmVlWzBdLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0cmVlWzBdLmxlbmd0aCA9PT0gdHJlZVsxXS5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0LnNsaWNlKC0xKSA9PT0gJzonKSB7XG4gICAgICAgIHVubmFtZWQgKz0gY29uZmlnLnBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgdW5uYW1lZCArPSBjb25maWcucGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIHJldHVybiBbdW5uYW1lZCwgdHJlZVsxXV07XG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlKHF1ZXJ5LCBwYXJhbXNPYmopIHtcbiAgICBsZXQgdHJlZTtcbiAgICBpZiAoY2FjaGUgJiYgKHRyZWUgPSBjYWNoZS5nZXQocXVlcnkpKSkge1xuICAgICAgcmV0dXJuIHRvQXJyYXlQYXJhbXModHJlZSwgcGFyYW1zT2JqKTtcbiAgICB9XG4gICAgdHJlZSA9IGpvaW4ocGFyc2UocXVlcnkpKTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnNldChxdWVyeSwgdHJlZSk7XG4gICAgfVxuICAgIHJldHVybiB0b0FycmF5UGFyYW1zKHRyZWUsIHBhcmFtc09iaik7XG4gIH1cblxuICBjb21waWxlLnBhcnNlID0gcGFyc2U7XG4gIHJldHVybiBjb21waWxlO1xufVxuXG4vLyBuYW1lZCA6b25lIDp0d28gdG8gcG9zdGdyZXMtc3R5bGUgbnVtYmVyZWQgJDEgJDIgJDNcbmZ1bmN0aW9uIHRvTnVtYmVyZWQocSwgcGFyYW1zKSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZShxKTtcbiAgY29uc3QgcGFyYW1zQXJyID0gW107XG4gIGlmICh0cmVlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBbdHJlZVswXSwgcGFyYW1zQXJyXTtcbiAgfVxuXG4gIGNvbnN0IHBJbmRleGVzID0ge307XG4gIGxldCBwTGFzdEluZGV4ID0gMDtcbiAgbGV0IHFzID0gJyc7XG4gIGxldCB2YXJJbmRleDtcbiAgY29uc3QgdmFyTmFtZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlWzBdLmxlbmd0aDsgKytpKSB7XG4gICAgdmFySW5kZXggPSBwSW5kZXhlc1t0cmVlWzFdW2ldXTtcbiAgICBpZiAoIXZhckluZGV4KSB7XG4gICAgICB2YXJJbmRleCA9ICsrcExhc3RJbmRleDtcbiAgICAgIHBJbmRleGVzW3RyZWVbMV1baV1dID0gdmFySW5kZXg7XG4gICAgfVxuICAgIGlmICh0cmVlWzFdW2ldKSB7XG4gICAgICB2YXJOYW1lc1t2YXJJbmRleCAtIDFdID0gdHJlZVsxXVtpXTtcbiAgICAgIHFzICs9IGAke3RyZWVbMF1baV19JCR7dmFySW5kZXh9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXMgKz0gdHJlZVswXVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtxcywgdmFyTmFtZXMubWFwKChuKSA9PiBwYXJhbXNbbl0pXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDb21waWxlcjtcbm1vZHVsZS5leHBvcnRzLnRvTnVtYmVyZWQgPSB0b051bWJlcmVkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/named-placeholders/index.js\n");

/***/ })

};
;